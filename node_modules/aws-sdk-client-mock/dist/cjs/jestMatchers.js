"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliasMatchers = exports.baseMatchers = exports.processMatch = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
const assert_1 = tslib_1.__importDefault(require("assert"));
/**
 * Prettyprints command calls for message
 *
 * @param ctx
 * @param calls
 * @returns
 */
function printCalls(ctx, calls) {
    return calls.length > 0 ? [
        'Calls:',
        '',
        ...calls.map((c, i) => `  ${i + 1}. ${c.args[0].constructor.name}: ${ctx.utils.printReceived(c.args[0].input)}`)
    ] : [];
}
function processMatch({ ctx, mockClient, command, check, input, message, }) {
    (0, assert_1.default)(command &&
        typeof command === 'function' &&
        typeof command.name === 'string' &&
        command.name.length > 0, 'Command must be valid AWS Sdk Command');
    const calls = mockClient.calls();
    const commandCalls = mockClient.commandCalls(command, input);
    const { pass, data } = check({ calls, commandCalls });
    const msg = () => {
        const cmd = ctx.utils.printExpected(command.name);
        const client = mockClient.clientName();
        const msgParams = {
            calls,
            client,
            cmd,
            data,
            commandCalls,
            notPrefix: ctx.isNot ? 'not ' : '',
        };
        return message(msgParams).join('\n');
    };
    return { pass, message: msg };
}
exports.processMatch = processMatch;
/* Using them for testing */
exports.baseMatchers = {
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommandTimes} matcher
     */
    toHaveReceivedCommandTimes(mockClient, command, expectedCalls) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            input: undefined,
            check: ({ commandCalls }) => ({ pass: commandCalls.length === expectedCalls, data: {} }),
            message: ({ client, cmd, commandCalls, notPrefix }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd} ${this.utils.printExpected(expectedCalls)} times`,
                `${client} received ${cmd} ${this.utils.printReceived(commandCalls.length)} times`,
                ...printCalls(this, commandCalls),
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommand} matcher
     */
    toHaveReceivedCommand(mockClient, command) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            input: undefined,
            check: ({ commandCalls }) => ({ pass: commandCalls.length > 0, data: {} }),
            message: ({ client, cmd, notPrefix, commandCalls }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd}`,
                `${client} received ${cmd} ${this.utils.printReceived(commandCalls.length)} times`,
                ...printCalls(this, commandCalls),
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommandWith} matcher
     */
    toHaveReceivedCommandWith(mockClient, command, input) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            input,
            check: ({ commandCalls }) => ({ pass: commandCalls.length > 0, data: {} }),
            message: ({ client, cmd, calls, notPrefix, commandCalls }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd} with ${this.utils.printExpected(input)}`,
                `${client} received ${cmd} ${this.utils.printReceived(commandCalls.length)} times`,
                ...printCalls(this, calls),
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedNthCommandWith} matcher
     */
    toHaveReceivedNthCommandWith(mockClient, call, command, input) {
        (0, assert_1.default)(call && typeof call === 'number' && call > 0, 'Call number must be a number and greater as 0');
        return processMatch({
            ctx: this,
            mockClient,
            command,
            check: ({ calls }) => {
                const received = calls[call - 1].args[0];
                return {
                    pass: received instanceof command && this.equals(received.input, input),
                    data: {
                        received,
                        cmd: this.utils.printReceived(received.constructor.name),
                    },
                };
            },
            input,
            message: ({ cmd, client, calls, data, notPrefix }) => [
                `Expected ${client} to ${notPrefix}receive ${call}. ${cmd}`,
                `${client} received ${call}. ${data.cmd} with input`,
                this.utils.printDiffOrStringify(input, data.received.input, 'Expected', 'Received', false),
                ...printCalls(this, calls),
            ],
        });
    },
};
/* typing ensures keys matching */
exports.aliasMatchers = {
    toReceiveCommandTimes: exports.baseMatchers.toHaveReceivedCommandTimes,
    toReceiveCommand: exports.baseMatchers.toHaveReceivedCommand,
    toReceiveCommandWith: exports.baseMatchers.toHaveReceivedCommandWith,
    toReceiveNthCommandWith: exports.baseMatchers.toHaveReceivedNthCommandWith,
};
// Skip registration if jest expect does not exist
if (typeof expect !== 'undefined' && typeof expect.extend === 'function') {
    expect.extend({ ...exports.baseMatchers, ...exports.aliasMatchers });
}
//# sourceMappingURL=jestMatchers.js.map